### 问题：

    1. 如果我是2000年1月1日出生，那么，到2021年1月1日，我几岁了？

    答案是：2021-2000 = 21岁

数学中的计算，计算的都是容量。
编程中，对于一个容器而言，访问容器中的元素，使用的是索引。\
开区间和闭区间。有两个数a和b,a小于b,[a,b] 这是闭区间，它包含a和b,和a,b之间的数。(a,b),不包含a和b。

有一个很不严谨的论述：数学中第一个序列的第一个位置是从1开始，编程中第一个位置是从零开始。不严谨的地方在于，生活常用数学，数字常常代表它本身，表示一个直接实体，编程中，一切皆指针，此时，例如一个数组的数字代表的是它的索引。从最后的结果上来看，确实是数学从1开始，编程从0开始。

感受一下这两者之间的差距吧。
共用100个苹果，把它们从1到100编号，分给4个小朋友（成年人）,那么每个人得到100/4=25个。
一个搞不清楚状况的分发是 1-25，25-50，50-75，75-100。这是错的，因为像25，50，75这样序号的苹果只有1个，这些是边界值。

正确的是 1-25，26-75，76-100。然后，发现 25-1 = 24，这与每个人25个苹果是否不符合？
离散和连续的概念。
加减，操作的都是闭区域，25-1把本身也减掉了，但是1事实上是被包含再内的。


为什么编程语言中，索引要从0开始？也就是说，如果想取出第一个数据，那么就从0开始。
根据计算机模型，所有数据都必须有一个索引（指针），软件操作的二进制是离散的，但是在物理结构上，必须以连续构成离散。如果在抽象上，从1开始计数，那么就完全忽略了物理结构以连续构成离散的状况。从0开始，是非常合适的抽象。

谈论编程吧。
```cpp
std::vector<int> m{1,2,3,4};
m.size();//这个是容量 等于4
for(int i = 0;i<m.size();i++>) {
    m.at(i);//i,这个数字的含义是一维容器的索引，m的索引为0，1，2，3.4就越界了。
} 



 std::vector<int> n(101,12);//实例化一个容量为101,每个指为12的vector容器

    int distance = 101/4; //25 接下来，把n分为四组，第一组所有数据设为1，。。。第四组所有数据设为4.

    
    for(int i = 1;i<=4;i++) { //这里的遍历完全以数目来考虑，一般情况下，更符合计算机思维的是 i = 0;i<4
        int j = (i-1)*distance;
        auto l_ = [&i,&j,distance,&n]()->bool{
            return (i+1)*distance>n.size()?(j<n.size()):(j<i*distance);//j<i*distance 也可以表示为j<=i*distance -1,这样可能更符合“容量的计算”
        };
        for(;l_();++j) { 
            if(j==100) {
               int x =  i;
            }
            n[j] = i;
        }
    }
    std::vector<int> groupNumber(4,0);
    for (auto& X:n)
    {
        switch (X)
        {
        case 1:
            groupNumber[0] = groupNumber.at(0)+1;
            break;
        case 2:
            groupNumber[1] = groupNumber.at(1)+1;
            break;
        case 3:
            groupNumber[2] = groupNumber.at(2)+1;
            break;
        case 4:
             groupNumber[3] = groupNumber.at(3)+1;
            break;
        default:
            break;
        }
        /* code */
    }
    for(auto& Y:groupNumber) {
        std::cout<<Y<<std::endl;//打印结果是25，25，25，26
    }

```

因为小于和小于等于的都是经常使用的，抽象为索引和容量计算，它们的边界并没有那么清晰，上面的例子好好感受一下把。

Note:
    写多线程/多进程代码时，在等额分配资源上花费了不少时间，深入思考一下，以为下次碰到的时候提高效率。


