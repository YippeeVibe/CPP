# NOTE:

$$
f(x)=\int_{-\infty}^{\infty}
\hat f(\xi)\,e^{2 \pi i \pi i \xi x}\,d\xi
$$

编写Qt程序时，使用QString 是最好的选择，如果不使用Qt的库，使用std::string是最好的选择。


根据惯例，注释应该卸载一个函数或者一个类的上方，在它们被声明的时候。


定期删掉无用的注释和冗(rong)余的代码，不管是无用的注释和冗余的代码都带来强大的迷惑性，它们在一开始是有用的，但会逐渐没用。完全没用时应该删除它们，或者做一个备注：暂时无用。



QT代码中，处于包含关系最上层的是一个GUI，这是约定成俗的规定，所以Qt代码的也按照这个来。让GUI类包含处理信息的类，实现GUI和业务分离。总之不应该存在一个处理的业务逻辑的类不被任何GUI类包含的情况。



应该注意到编译器优化。很多情况下会担心多余的复制，但是这种情况下，大多数编译器会进行优化，不必要的复制是不会傻傻的存在的。


C++指针语义和引用语义的区别是，通常是对象实在栈中分配还是在堆中分配。控制对象在栈中分配内存还是堆中分配内存,主流编程语言中，C++是唯一可以控制的。


## 1.6. 资源管理

与其说C++有智能指针，倒不如说C++有4种指针 unique_ptr,shared_ptr,weak_ptr和裸指针。uniuqe_ptr更多搭配裸指针，
shared_ptr和weak_ptr搭配场景更多。当需要使用C++指针时，首先是需要在堆中分配内存，和跨作用域传递值。C++指针真正解决的是资源所有权的问题。

1. 使用QT,继承QObject的类使用裸指针new创建，在主动释放时使用 deleteLater()函数（qt对象系统根据父子关系管理内存）。

2. 除Qt外不要使用new/delete 创建销毁对象，使用智能指针自动创建和销毁对象。

3. 智能指针只应该解决资源管理的问题。资源管理的本意是，当创建资源时就应该指定销毁资源的对象，不管如何，最终一定要销毁支援，使用智能指针避免手动释放资源。但一些对象不负责资源的销毁时，他应该使用裸指针俩寻找对象。所以，不应该传递智能指针对象，在函数中应传递裸指针。

4. 函数形参中传递裸指针。

```cpp
class A:public QObject {
    Q_OBJECT
}

A *a = new A();
a->deleteLater();

class B {
public:

}

std::unique_ptr<B> b = std::make_unique<B>();
```



## 1.7. 设计原则

### 1.7.1. 设计模式的使用

尽量不要使用单例模式，特别是操作频繁的部分。首先，单例模式在使用了可能不安全的static 变量,再则单例模式可能被滥用（带来需求更改的许多问题）。使用可以代替单例模式的依赖注入模式。

### 1.7.2. 模块化技巧

qt编程中，尽量避免将GUI和业务代码写到一切，当程序规模稍微大一点时，这是非常麻烦的。

### 1.7.3. 资源分配

如果一块资源在整个程序期间都存在，并且，依赖这块资源的模块很多，尤其时整个程序围绕着这块资源转，应该把它设为全局的，通过依赖注入模式授权给其它模块使用。


## 多使用自动化工具。

例如，多使用自动化工具重构项目，使用自动化工具检查改善代码风格。


## CMake 

重要且肯定的是CMake正在成为C++事实上的编译管理标准。
