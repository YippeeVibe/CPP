编程 = 数据结构+算法。（预计在学习完成更底层的知识时更新。）
为什么指针如此重要？编程所做的无非就是数据和控制数据的方法，但无论是方法还是数据，都必须以二进制的形式存储，所以，编程所做的事情再抽象一下，就是编程所做的事情就是数据。指针表示的是数据的存储位置，指针就是一切！


函数是指针是指针就是一切的子集。
刚开始学习编程的时候，以为指针固有的指向数据，后来实践中发现，首先有存储传递方法的需求，其次能用C++函数指针轻而易举的实现！

对于函数的第一印象：函数是方法。后来理解方法也是一种数据，所以函数也是一种数据。
C++中，函数，它的数据有且仅有一下要素。
1. 返回类型。
   如果程序员不需要调用的函数返回值，可以声明返回类型位void（void*表示可以指向任何类型的指针，声明返回类型为void*的函数需要返回一个指针）
   不能把void看作NULL。

   特殊一点的是,C++的构造函数和析构函数，它们的返回值可以看作固定，程序员不该有权限指定他们的返回值，所以也不能指定他们的返回类型。

   Note:使用std::tuple可以更加灵活的指定函数的返回值。
   ```cpp
   void f();//显式表示程序员不需要这个函数有返回值，但实际上，这个函数有返回值，调用这个函数之后返回的是调用地址。void!=空

   void* f1();//返回任意类型的指针。

   class A{
      A();//构造函数和析构函数，均不可执行返回值。
      ~A();
   }
   ```
2. 形参列表，接受什么样的参数。
   函数接受什么类型的输入。
   ```cpp
   //函数接受一个任意类型的指针
   void f(void*);

   //函数接受不定参数，count指调用时不定参数的数目，在调用时指定。C风格。
   void f1(int count,...)
   {
      //实现
      va_list args;
      va_start(args,count)
      while(count--)
      {
         //doSomething
      }
      va_end(args);
   }
   template<typename T>
   void f2(T);//一个模板函数，编译器自动推断类型。

   //toDO可变参数模板。
   ```

3. 函数被谁所拥有。
   
   面向对象编程范式中，一个函数被一个类拥有，作为一个类的成员函数；在面向过程范式中，一个函数是个“裸”函数。

理解了函数的基本要素，就可以理解函数是可以被存储，复制和移动的。
```cpp
void f(int);//声明一个函数 不被任何类拥有，返回类型void 接受形参 int 

void (*pf)(int);//声明一个函数指针，

pf = f;//要素相同的函数可以被赋值

pf(3);//与调用 f(3)效果相同。
```

如果在类中使用函数指针，语法还是有些复杂的。
```cpp
class A;
class B
{
public:
    void (A::* pf)();//在类B中存储一个类A中的函数 没有初始化

    void (B::*pf1)() { nullptr };//在类B中存储一个类B中的函数 初始化为nullptr
    A* a{ nullptr };

    void f()
    {
        (a->*(this->pf))();//调用

    }
};

class A
{
public:
    void f()
    {

    }


};

int main()
{
	A a;
	B b;
	b.a = &a;

	b.pf1 = &B::f; //赋值！
	b.pf = &A::f;//赋值！

	(b.*(b.pf1))();//调用
	(a.*(b.pf))();//调用。 
}
```
理解函数指针十分简单，1.函数指针属于谁？2.函数被谁所拥有？3.指针只有解引用才能取出值，否者只表示一段地址。

在大部分编译器中，这些语法也是可以的
```cpp
void f();
void (*pf)();

pf = f;//OK
pf = &f;//OK

pf();//OK

(*pf)();//OK

```
C中并没有类的概念，这样做是在没有二义性的原则下保持与C的兼容？

指针是构成一切的基础！有时候，我们可能需要其它的更适合场景的实现方式，C++标准库对函数式编程有非常好的支持，使用它们可以完全代替函数指针，并且不会带来额外的开销，相比于使用指针能够更好的理解底层，使用标准库能够更好的理解抽象，更方便的处理业务！
```cpp
#include<functional>

```